[{"title":"【nginx】nginx配置-Linux","url":"/2021/11/14/【nginx】nginx配置-Linux/","content":"\n","tags":["Linux","nginx"],"categories":["nginx"]},{"title":"【nginx】nginx配置-Windows","url":"/2021/11/14/【nginx】nginx配置-Windows/","content":"\n","tags":["nginx"],"categories":["nginx"]},{"title":"【mysql】centos 安装mysql","url":"/2021/01/08/【MySQL】centos 安装mysql/","content":"\nmysql是我们最常用的开源的关系型数据库，mysql不同版本有时候安装的方式也不尽相同，下面以mysql5.7.28版本为例梳理一下安装细节：\n\n1.下载mysql-5.7.28，URL：https://downloads.mysql.com/archives/community/ 我这里下载的是64位版本\n\n![img](https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200206223141847-158152537.png)\n\n 下载后文件为：mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz\n\n \n\n\\2. 卸载自带的mariadb和mysql\n\n检查是否安装了mariadb和mysql，有时候默认安装了\n\n```\nrpm -qa | grep mariadb\nrpm -qa | grep mysql\n```\n\n如果没有，就可以安装mysql，如果有，需要先卸载（remove后为上面命令查询到的内容，全文件名，我这里没有，没法展示）\n\n```\nyum remove mariadb-xxx\n```\n\n \n\n3.解压文件，修改目录名方便配置\n\n```\ntar -zxvf mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz -C /opt/soft/\ncd /opt/soft\nmv mysql-5.7.28-linux-glibc2.12-x86_64 mysql-5.7.28\n```\n\n \n\n4.在/usr/local/目录下创建到/opt/soft/mysql-5.7.28的软链接\n\n```\ncd /usr/local\nln -s /opt/soft/mysql-5.7.28 mysql\n```\n\n![img](https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200206223541446-246835672.png)\n\n \n\n5.添加mysql用户，修改mysql目录权限，并用此用户执行应用\n\n```\nuseradd -s /bin/false -M mysql\ncd /opt/soft\nchown -R mysql:mysql mysql-5.7.28\n```\n\n \n\n6.拷贝配置文件，将mysql的配置文件拷贝为/etc/目录下的my.cnf，并修改配置文件\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n![复制代码](https://common.cnblogs.com/images/copycode.gif)\n\n```\nvim /etc/my.cnf[mysqld]\n# binlog 配置\nlog-bin=/usr/local/mysql/logs/mysql-bin.log\nexpire-logs-days=14\nmax-binlog-size=500M\nserver-id=1\n# GENERAL\nbasedir=/usr/local/mysql\ndatadir=/usr/local/mysql/data\nsocket=/usr/local/mysql/mysql.sock\nuser=mysql\ndefault-storage-engine=InnoDB\ncharacter-set-server=utf8lower_case_table_names = 1explicit_defaults_for_timestamp=true\n[mysqld_safe]\nlog-error=/usr/local/mysql/mysql-error.log\npid-file=/usr/local/mysql/mysqld.pid\n[client]\nsocket=/usr/local/mysql/mysql.sock\n[mysql]\ndefault-character-set=utf8\nsocket=/usr/local/mysql/mysql.sock\n```\n\n![复制代码](https://common.cnblogs.com/images/copycode.gif)\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n \n\n7.安装mysql，进入mysql目录执行以下命令\n\n```\ncd /opt/soft/mysql-5.7.28\nbin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data\n```\n\n如果出现如下错误，说明需要安装依赖包：\n\n![img](https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200206204025053-609859232.png)\n\n 安装autoconf依赖包：\n\n```\nyum -y install autoconf\n```\n\n再次执行脚本\n\n如果出现以下错误，说明在my.cnf中指定的binlog配置文件的logs文件夹不存在：\n\n![img](https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200206204921524-155353802.png)\n\n 在/usr/local/mysql/下创建logs文件夹就行了，并改为mysql用户\n\n![img](https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200206205102036-2078103300.png)\n\n再次执行脚本\n\n出现以下信息，代表成功，要保存一下密码，\n\n![img](https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200206225227432-756771816.png)\n\n \n\n8.拷贝启动程序，将mysql的启动程序拷贝到/etc/init.d/目录下\n\n```\ncp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld\n```\n\n![img](https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200205224121762-1591100937.png)\n\n \n\n 9.安装完，启动mysql服务\n\n```\nservice mysqld start\n```\n\n如果出现如下错误：\n\n```\n[root@s144 support-files]# service mysqld start\nStarting MySQL.2020-01-31T23:14:27.412533Z mysqld_safe error: log-error set to '/usr/local/mysql/mysql-error.log', however file don't exists. Create writable for user 'mysql'.\n ERROR! The server quit without updating PID file (/usr/local/mysql/data/s144.pid).\n```\n\n说明mysql-error.log不存在，手动去创建，并修改权限\n\n```\ncd /opt/soft/mysql-5.7.28\ntouch mysql-error.log\nchown mysql:mysql mysql-error.log\n```\n\n![img](https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200206230023984-1929932614.png)\n\n 出现SUCCESS，说明启动成功\n\n ![img](https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200206230211710-1092214077.png)\n\n \n\n10.配置环境变量，编辑/etc/profile，方便在任何地方用mysql命令\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n![复制代码](https://common.cnblogs.com/images/copycode.gif)\n\n```\nvim /etc/profile\n```\n\n\\#mysql\nexport MYSQL_HOME=/usr/local/mysql\nexport PATH=$PATH:$MYSQL_HOME/bin\n\n![复制代码](https://common.cnblogs.com/images/copycode.gif)\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n别忘记重新编译 /etc/profile\n\n```\nsource /etc/profile\n```\n\n \n\n11.登录mysql，修改密码\n\n首次登录没有密码，提示输入密码时，输入第7步安装时生成的密码：p5j2jfX7am.h\n\n```\nmysql -uroot -p\n```\n\n![img](https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200206230815269-811672369.png)\n\n 这里要先使用alter user重置密码，不然会报错，我这里 修改mysql root用户密码 为 111111 ：\n\n```\nmysql> alter user 'root'@'localhost' identified by '111111';\nmysql> flush privileges;\n```\n\n![img](https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200206231601228-1594582365.png)\n\n 至此本机登录密码修改完成，若是想让其他机器访问，需要配置远程访问：\n\n```\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '111111' WITH GRANT OPTION;\n```\n\n使用远程工具测试一下：\n\n![img](https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200206231804083-1287096483.png)\n\n 至此搭建mysql-5.7.28版本就完成了\n\n \n\n12.一些常用命令 \n\n```\nservice mysqld start 　　　 #启动\nservice mysqld stop        #关闭 　　　\nservice mysqld restart　　  #重启 　　　\nservice mysqld status 　　  #查看运行状态 \n```","tags":["MySQL","CentOS"],"categories":["Linux","MySQL"]},{"title":"【linux】不存在sudoer","url":"/2021/01/08/【Linux】不存在sudoer/","content":"\n\n用户 不在 sudoers 文件中。此事将被报告。\n\n普通linux用户使用sudo命令执行只有root用户才可以执行的命令时出现了该错误，如下图示：\n\n![](不存在sudoer\\20190712095902322.png)\n\n简单说明一下操作。命令$ ll /etc/sudoers表示查看文件的属性，属性包括有：文件拥有者、文件所属组以及其他用户组对该文件拥有的读写权限和文件的类型等，上图的/etc/sudoers文件表示拥有者和所属组都是root且只能读取，其他用户组的没有任何读写权限。\n\n命令$ sudo cat /etc/sudoers表示当前登录用户是普通用户zouqi，我想使用该用户查看/etc/sudoers文件的内容，由于需要有root权限才能查看该文件的内容，于是使用sudo命令来让普通用户临时拥有root权限来执行查看内容命令，但是后面输入密码后发现命令无法成功执行（查看失败了），报错标题所诉zouqi 不在 sudoers 文件中。此事将被报告。错误。\n\n解决方案\n根据错误提示，只需将当前登录用户，图中所示用户是zouqi加入到sudoers文件中即可。\n\n切换至root用户\n$ su - root\n![](不存在sudoer\\20190712102620727.png)\n\n给root用户添加可写权限\nchmod 640 /etc/sudoers\n![](不存在sudoer\\20190712102855624.png)\n\n\n修改sudoers文件\n```bash\n# vim /etc/sudoers\n```\n![](不存在sudoer\\20190712103601971.png)\n\n如上图所示位置加上zouqi ALL=(ALL) ALL后，按下esc键，输入:wq保存修改并退出编辑。\n\n查看是否修改成功\n```bash\n# cat /etc/sudoers\n```\n![](不存在sudoer\\20190712103947180.png)\n\n可以看到已经成功添加了用户zouqi到sudoers文件中。\n\n修改sudoers文件：只读权限（原有权限）\n```bash\n\tchmod 440 /etc/sudoers\n```\n\n普通用户继续使用sudo命令验证\n# exit\n![](不存在sudoer\\20190712104509383.png)\nexit表示返回普通用户zouqi\n\n```bash\nsudo cat /etc/sudoers\n```\n\n\nsudo命令继续查看sudoers文件内容验证结果。如下图示：\n\n![](不存在sudoer\\20190712104814766.png)\n\n根据图示可知问题已经解决。","tags":["Linux","auther","sudoer"],"categories":["Linux"]},{"title":"【liunx】centos防火墙","url":"/2021/01/08/【Linux】centos防火墙/","content":"##### 一、centos7以上版本\n```sh\n1.firewalld的基本使用\n启动：  systemctl start firewalld\n查状态：systemctl status firewalld \n停止：  systemctl disable firewalld\n禁用：  systemctl stop firewalld\n在开机时启用一个服务：systemctl enable firewalld.service\n在开机时禁用一个服务：systemctl disable firewalld.service\n查看服务是否开机启动：systemctl is-enabled firewalld.service\n查看已启动的服务列表：systemctl list-unit-files|grep enabled\n查看启动失败的服务列表：systemctl --failed\n2.配置firewalld-cmd\n查看版本： firewall-cmd --version\n查看帮助： firewall-cmd --help\n显示状态： firewall-cmd --state\n查看所有打开的端口： firewall-cmd --zone=public --list-ports\n更新防火墙规则： firewall-cmd --reload\n查看区域信息:  firewall-cmd --get-active-zones\n查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0\n拒绝所有包：firewall-cmd --panic-on\n取消拒绝状态： firewall-cmd --panic-off\n查看是否拒绝： firewall-cmd --query-panic\n3.那怎么开启一个端口呢\n添加\nfirewall-cmd --zone=public(作用域) --add-port=80/tcp(端口和访问类型) --permanent(永久生效)\nfirewall-cmd --zone=public --add-service=http --permanent\nfirewall-cmd --reload    # 重新载入，更新防火墙规则\nfirewall-cmd --zone= public --query-port=80/tcp  #查看\nfirewall-cmd --zone= public --remove-port=80/tcp --permanent  # 删除\n\nfirewall-cmd --list-services\nfirewall-cmd --get-services\nfirewall-cmd --add-service=<service>\nfirewall-cmd --delete-service=<service>\n在每次修改端口和服务后/etc/firewalld/zones/public.xml文件就会被修改,所以也可以在文件中之间修改,然后重新加载\n使用命令实际也是在修改文件，需要重新加载才能生效。\n\nfirewall-cmd --zone=public --query-port=80/tcp\nfirewall-cmd --zone=public --query-port=8080/tcp\nfirewall-cmd --zone=public --query-port=3306/tcp\nfirewall-cmd --zone=public --add-port=8080/tcp --permanent\nfirewall-cmd --zone=public --add-port=3306/tcp --permanent\nfirewall-cmd --zone=public --query-port=3306/tcp\nfirewall-cmd --zone=public --query-port=8080/tcp\nfirewall-cmd --reload  # 重新加载后才能生效\nfirewall-cmd --zone=public --query-port=3306/tcp\nfirewall-cmd --zone=public --query-port=8080/tcp\n4.参数解释\n–add-service #添加的服务\n–zone #作用域\n–add-port=80/tcp #添加端口，格式为：端口/通讯协议\n–permanent #永久生效，没有此参数重启后失效\n5.详细使用\nfirewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"192.168.0.4/24\" service name=\"http\" accept'    //设置某个ip访问某个服务\nfirewall-cmd --permanent --zone=public --remove-rich-rule='rule family=\"ipv4\" source address=\"192.168.0.4/24\" service name=\"http\" accept' //删除配置\nfirewall-cmd --permanent --add-rich-rule 'rule family=ipv4 source address=192.168.0.1/2 port port=80 protocol=tcp accept'     //设置某个ip访问某个端口\nfirewall-cmd --permanent --remove-rich-rule 'rule family=ipv4 source address=192.168.0.1/2 port port=80 protocol=tcp accept'     //删除配置\n\nfirewall-cmd --query-masquerade  # 检查是否允许伪装IP\nfirewall-cmd --add-masquerade    # 允许防火墙伪装IP\nfirewall-cmd --remove-masquerade # 禁止防火墙伪装IP\n\nfirewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080   # 将80端口的流量转发至8080\nfirewall-cmd --add-forward-port=proto=80:proto=tcp:toaddr=192.168.1.0.1 # 将80端口的流量转发至192.168.0.1\nfirewall-cmd --add-forward-port=proto=80:proto=tcp:toaddr=192.168.0.1:toport=8080 # 将80端口的流量转发至192.168.0.1的8080端口\n```\n\n##### 二、centos7以下版本\n\n```sh\n1.开放80，22，8080 端口\n/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT\n/sbin/iptables -I INPUT -p tcp --dport 22 -j ACCEPT\n/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT\n2.保存\n/etc/rc.d/init.d/iptables save\n3.查看打开的端口\n/etc/init.d/iptables status\n4.关闭防火墙 \n1） 永久性生效，重启后不会复原\n开启： chkconfig iptables on\n关闭： chkconfig iptables off\n2） 即时生效，重启后复原\n开启： service iptables start\n关闭： service iptables stop\n```","tags":["fireawall","centos","Linux"],"categories":["Linux"]},{"title":"【mysql】MySQL创建用户","url":"/2021/01/08/【MySQL】MySQL创建用户/","content":"\n```sh\n### 一. 创建用户\n\n命令:CREATE USER 'username'@'host' IDENTIFIED BY 'password';\n\n\n\n说明：\nusername：你将创建的用户名\nhost：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%\npassword：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器\n例子：\nCREATE USER 'dog'@'localhost' IDENTIFIED BY '123456';\nCREATE USER 'pig'@'192.168.1.101_' IDENDIFIED BY '123456';\nCREATE USER 'pig'@'%' IDENTIFIED BY '123456';\nCREATE USER 'pig'@'%' IDENTIFIED BY '';\nCREATE USER 'pig'@'%';\n\n### 二. 授权:\n\n命令:GRANT privileges ON databasename.tablename TO 'username'@'host'\n说明:\nprivileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL\ndatabasename：数据库名\ntablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，如*.*\n例子:\nGRANT SELECT, INSERT ON test.user TO 'pig'@'%';\nGRANT ALL ON *.* TO 'pig'@'%';\nGRANT ALL ON maindataplus.* TO 'pig'@'%';\n注意:\n用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:\nGRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;\n\n### 三.设置与更改用户密码\n\n命令:SET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword');\n\n如果是当前登陆用户用:\nSET PASSWORD = PASSWORD(\"newpassword\");\n例子:\nSET PASSWORD FOR 'pig'@'%' = PASSWORD(\"123456\");\n\n\n### 四. 撤销用户权限\n命令:REVOKE privilege ON databasename.tablename FROM 'username'@'host';\n说明:\nprivilege, databasename, tablename：同授权部分\n\n例子:\nREVOKE SELECT ON *.* FROM 'pig'@'%';\n注意:\n假如你在给用户'pig'@'%'授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO 'pig'@'%'，则在使用REVOKE SELECT ON *.* FROM 'pig'@'%';命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON *.* TO 'pig'@'%';则REVOKE SELECT ON test.user FROM 'pig'@'%';命令也不能撤销该用户对test数据库中user表的Select权限。\n\n具体信息可以用命令SHOW GRANTS FOR 'pig'@'%'; 查看。\n\n\n### 五.删除用户\n命令:DROP USER 'username'@'host';\n```\n\n","tags":["MySQL"],"categories":["Linux","MySQL"]},{"title":"【Java】About 注解","url":"/2021/01/08/【Java】注解/","content":"\n## 什么是注解？\n\n   我们学习注解的第一步，首先就是先从最基本的开始，看看注解到底是什么？\n\n   > 注解和反射是Java中非常让人容易忽略的东西，但却很重要，在主流的Spring中更是充满了注解，注解和注释很像，两者其实本质就差不多，注释是给我们程序员看的，而注解呢其实就是给程序看的(关于反射，下一篇咱就开讲)\n\n   上面所说希望你着重注意以下两点：\n\n   1、注解和注释很像\n   2、注释是给我们程序员看的，而注解呢其实就是给程序看的\n\n   我们初步理解注解就从上面两点开始，我们先看注释，比如这样：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kX2U5YWQ1MDJkZTVmNjZmYjhlYmRkNzgxN2E4M2NmZWQ4LmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_e9ad502de5f66fb8ebdd7817a83cfed8.jpg)\n\n   这就是一个注释，那么注释有什么用呢？简单来说就是对相关的类或者方法加以说明，比如这里的Test类，上面的注释大致告诉我们这类是谁编写的，做什么的以及何时编写的这些信息，当然，信息其实还可以有更多。\n\n   所以，你要明白，注释是干嘛的，是给我们这些程序员看的，看到注释我们就明白了，哦，这个类原来是这样的……\n\n   注释是给程序员看的，那么注解呢？相差一个字，注解是给程序看的，先记住即可。\n\n   ### 进一步理解注解\n\n   上面我们说了，注解和注释是很像的，注释是给我们人看的，注解就是给程序看的，前面的好理解，这个注解是给程序看的，你或许还有一点懵，我进一步解释下。\n\n   首先，直观感觉下什么是注解，比如我们在代码中写的这个：\n\n   ```java\n   /**\n    * @Description 用户类\n    * @Author ithuangqing\n    * @Date 2020-07-31 15:33\n    **/\n   @Repository\n   public class UserBean {\n       private String name;\n       private int age;\n   }\n   12345678910\n   ```\n\n   这里的@Repository就是一个注解，看这段代码，上面还有注释，我们看到注释，发现都看得明白，但是看到@Repository之后，就不那么明白，这是啥，有啥用？\n\n   于是我们查，大概知道，哦，这是个注解，有了这个注解，UserBean就会被装载进Spring容器中，我们可以知道这些信息，但是，它实际上做了哪些事情，是如何起作用，也就是如何把UserBean交给Spring去处理的，这个内部实现，我们不清楚。\n\n   但是，我们虽然不清楚，有个东西它清楚，什么呢？就是一个特定的程序，也就是说，有一个专门的程序，当它看到这个UserBean上面有一个@Repository之后，这个程序就知道了，原来要把这个UserBean装载进Spring容器中，于是这个程序员就开始执行一系列的操作区把这个UserBean装载进Spring容器中。\n\n   所以，你到此应该明白：\n\n   > 注释是给人看到的，注解是给程序看的。\n\n   我们再进一步总结下什么是注解：\n\n   > 在程序中，可以把注解看成一种特殊的标记，一般是用来标记类，方法或者接口等，这些标记有一些特点，比如可以在编译的时候，（javac命令把java源文件编译成字节码文件class），类加载和运行的时候（使用java命令执行字节码文件的时候，类的生命周期开始，从加载到卸载）被读取到（一般是有专门的程序去读区这些注解，利用反射技术去解析注解，然后根据得到的信息做相应的处理）\n\n   是的，关于注解，你要知道这么一个知识点了：\n\n   > 对于注解，是有专门的程序去读取它，解析它，然后根据得到的消息去执行相应的操作。\n\n   关于这个程序，要看具体的场景，也就是说这个程序是不同的，那么关于这个程序怎么知道读到哪个注解该干嘛，这个还是依靠注解本身的定义，比如@Repository注解被定义成是把被注解的装载进Spring容器中，那么特有的程序获取到这个注解就知道该干什么事了。\n\n   到此，你应该知道什么是注解了，当然，是概念上的一些东西，另外，对注解是怎么起作用的，你也应该有点内味了……\n\n   ### 注解的简单分类\n\n   这个知识点很是轻松愉快，不需要你失去多少脑细胞。\n\n   注解是有分类的，一般有三种类型的注解：\n\n   1. 自定义注解（实际很少）\n   2. JDK内置注解（@Override检验方法重写）\n   3. 框架中的注解\n\n   不知道这个能不能理解，就是说，对于注解而言，是有几种不同分类的，首先，我们可以自己写一个注解出来（下面会讲），另外对于JDK本身而言有自己的的注解，我们看个代码，你就知道了：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzA0NjhlZjM4MTY4NjFlMjUzZTliOGI5MzE3ZTMxMjU0LmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_0468ef3816861e253e9b8b9317e31254.jpg)\n\n   比如这个，是重写toString方法，上面就有个JDK的内置注解@Override，这个注解就起到一个检验的作用，因为它是Object的方法，你现在要重写它，那么名字啊，参数啊要和之前的一样，不一样，就给你报错，不信你试试：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kX2E4YWYwOTM0NzdjNmE0MjU0MGU3MDZlZTJkMWViZGM1LmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_a8af093477c6a42540e706ee2d1ebdc5.jpg)\n\n   这个是关于JDK的内置注解，那么最后一个关于框架的注解，我想你只要学过Spring都知道，比如@Controller，熟悉吧，这就是框架中的注解。\n\n   ## 注解的本质\n\n   经过上面的讲解，我们应该大致了解了什么是注解，以及注解的一些分类，现在，我们对于概念上的注解算是清楚了，但是这个注解本质是个什么呢？\n\n   告诉你吧，注解的本质是个接口，为啥，先来看下，如何定义一个注解（下面会详细讲解）\n\n   ```java\n   public @interface Main {\n   }\n   12\n   ```\n\n   就这些，就定义了一个注解，不知道你发现了没，这个和接口很像啊，有啥区别，就是多了一个@，不然就是接口啊，接下来我们使用XJad把这个注解反编译一下看看：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzFiODdmNDM3OTQxMjhlMTQ4YWQzMzc2ZDg2YjFlZGY2LmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_1b87f43794128e148ad3376d86b1edf6.jpg)\n\n   看到没，这里的Main直接就是interface定义，然后还继承了Annotation，这个足以说明，注解其实就是接口啊。\n\n   这个暂且聊到这，记住即可！\n\n   ## 如何定义注解\n\n   接下来我们就来聊聊如何去自定义一个注解，我们在上面说过，注解的本质其实就是接口，上面也简单演示了一个注解的定义，如下：\n\n   ```java\n   public @interface Main {\n   }\n   12\n   ```\n\n   想一下，我们平常怎么定义一个接口，是不是使用关键字interface，那么类呢？是不是使用class关键字，也就是说啊，定义这些一般都是需要一个关键字来加以声明的，显而易见，定义注解的关键字就是@interface，它和接口的定义就是多了一个@，但是注解的定义却不仅仅是如此！\n\n   ### 元注解\n\n   这里要引入一个元注解的概念，我们先来想一下，注解我们上面说了，一般可以用来标记类，接口或者方法等，那么这里就有一个问题了，比如我定义了这么一个Main注解：\n\n   ```java\n   public @interface Main {\n   }\n   12\n   ```\n\n   那么，我这个注解是不是可以用在类上，也可以用在接口或者方法上？一般类呀，接口啊，方法啊等等它们还是有点差别的，所以对于这些最好有区分，也就是说，有些注解只能标记类，有些注解只能标记方法等，这样一来就需要对注解的作用域去进行限制。\n\n   那么这个该怎么搞，答案就是元注解，那什么是元注解呢？\n\n   > 元注解就是标记注解的注解\n\n   啥意思，来看下，比如我们定义的这个Main注解，我们规定它只能用来标记方法，那么可以这样做：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzkyZTY3N2JhNjYwMDUzMDdhYzUzYzlkZGUyZmI4MWVjLmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_92e677ba66005307ac53c9dde2fb81ec.jpg)\n\n   我们在上面加了一个注解@Target，后面还有参数（下面会讲），这个参数\n   ElementType.METHOD就代表我们这个注解是用于注解方法的，来，试一下：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzMyNzIyYWFlYzExODY0ODk3NGQxNDA4NWNmY2ZmZmE3LmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_32722aaec118648974d14085cfcfffa7.jpg)\n\n   你看，可以用在我们的main方法上，那么是不是不能用于类呢？我们试下：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kX2M2ZjBhZjg3NmNlMTc4NmRlOWU2ZDJiZTk1N2Y3MWE2LmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_c6f0af876ce1786de9e6d2be957f71a6.jpg)\n\n   报错了，看来是不行，所以这个@Target就是一个元注解，可以用来注解注解，也就是标记注解的注解。\n\n   关于元注解，一般有以下主要的几个：\n\n   1. @Documented 用于制作文档\n   2. @Target 指定注解的使用位置，不指定的话任何位置都可以使用\n   3. @Retention（注解的保留策略）\n\n   这里单独提一下最后一个也就是声明注解的保留策略@Retention，这个是什么意思呢？\n\n   这个保留策略啊，简单来讲就是说你这个注解可以在哪个时间段起作用，这个就得说说我们的代码从写出来，然后编译到执行的主要三个阶段了，画个图就是这样的：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzJkZTU4OWNmMGVlZmM5MDQyMmQwYmUyN2MxOTkzZTdlLmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_2de589cf0eefc90422d0be27c1993e7e.jpg)\n\n   这个我已经画的很清楚了吧，一般来说，我们的注解都是要保留到运行期间的，所以一般就是这样：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzY2OGYxNzNlYjRiMmM0Y2RhNDQ3ZGY0MzI0MzU1ZjExLmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_668f173eb4b2c4cda447df4324355f11.jpg)\n\n   当然，具体情况具体对待。\n\n   到这里你可能发现，这个注解里面可以有参数？当然是可以的，我这里简单演示下，下面讲到注解的语法的时候你就知道了：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzU1ZTdlZGE4OTU0NWJmMDU0NTFlMzQ3ZjkyZjdiZWMxLmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_55e7eda89545bf05451e347f92f7bec1.jpg)\n\n   然后再看下使用：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzE0NDEwMzE3ZGU0Mzk1ZjE4MWRkMmQxYWY2ZTY3OGNjLmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_14410317de4395f181dd2d1af6e678cc.jpg)\n\n   其实还是蛮简单的！\n\n   ## 注解的基本使用语法\n\n   接下来我们就来看看注解的语法吧，就是注解具体是如何使用的。\n\n   对于注解，我们知道了如何去定义它，比如简单定义一个注解：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzAwN2Y3M2U0ZDNkNzU5M2U5MDRkMGM1MjY3YTRkMWYzLmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_007f73e4d3d7593e904d0c5267a4d1f3.jpg)\n\n   这很简单，我们继续去看，对于注解还可以定义属性：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzU2NjM1OTRkMThjYzBjZmNmNTU2Mjc0N2U2NmNjMGQ2LmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_5663594d18cc0cfcf5562747e66cc0d6.jpg)\n\n   虽然这个属性看起来很像方法，但是人家就是属性，注解还是比较特殊的，那么现在我们来使用下这个注解：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzI1Y2Y4ZWQ3OGU4OTNiNzIxNGQzZTI2ZjM1MTQyZTY0LmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_25cf8ed78e893b7214d3e26f35142e64.jpg)\n\n   这个时候它会报错，告诉我们需要一个value值，其实也好理解，你的注解定义中定义的有一个value属性，那么你在使用的时候就需要把这个属性值给用上，那你说我可不可以不用，可以的，那定义注解属性的时候就需要给属性添加默认值，就是这样：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kX2M0YjQxMjcyYWYxMWY0YTk4NWJmOTFkY2VkNDNlNTAxLmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_c4b41272af11f4a985bf91dced43e501.jpg)\n\n   可以设置成一个空字符串也可以设置成具体的值。除此之外我们还可以设置多个属性值，像这样：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzZjNmEzNDVkOThkNzk5ZTYzYTA0MmQ4ZjhiMDk3YWMxLmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_6c6a345d98d799e63a042d8f8b097ac1.jpg)\n\n   这里就有知识点了，如果你在使用的时候只是给一个属性值赋值，那么在使用的时候可以这样：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kX2U4YWQwMzg2YjQxNzllNTFjNDJjYzNkOGNjNWU3MzRiLmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_e8ad0386b4179e51c42cc3d8cc5e734b.jpg)\n\n   那有人可能疑问，我这个hello对应的是value还是name啊，默认对应的都是value，所以这个要牢记。\n\n   但是给多个属性值赋值的时候就必须指明具体的属性名称了，就是这样：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzBjYTQ0ZjU1MWM2NGFjMjQxMDRjYzI4MmRmYWFjMWY2LmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_0ca44f551c64ac24104cc282dfaac1f6.jpg)\n\n   > PS：通过上面的介绍我们会发现注解一个比较奇怪的地方，就是对于注解而言，我们可以定义属性，但是注解的属性长得真的像方法，但是在注解里面，它就是属性，就可以直接赋值，这里需要注意下！\n\n   ### 属性的类型\n\n   上面简单介绍了注解的属性，那么这些属性都是可以取哪些类型值呢？大致有如下这么多：\n\n   1. 基本数据类型\n   2. String\n   3. 枚举\n   4. Class\n   5. 注解类型\n   6. 数组（以上类型的一维数组）\n\n   关于数组的看个例子，比如这样：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzYyMWZlYmU4MTNjZjYwNDdkZWMwZmRmOThlYTdkY2ZjLmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_621febe813cf6047dec0fdf98ea7dcfc.jpg)\n\n   使用的时候也是同样的道理：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzI5ZmFlOWFmODA2NWU2MWRlMWNkNTM4YmY4NTAxMDIyLmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_29fae9af8065e61de1cd538bf8501022.jpg)\n\n   ## 如何真正的理解注解\n\n   我们平常对于注解之所以忽视的原因在于，很多地方只需要我们去使用，比如这样：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kX2FiZDQ5OWRhY2NiMmVmMjMzMmQ3NDEyZTNkYTEwMDU1LmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_abd499daccb2ef2332d7412e3da10055.jpg)\n\n   至于注解是怎么定义的以及注解是怎么起作用的都不太了解，好像需要我们自定义注解的也都很少，所以不去系统化的学习注解的话，会忽略掉注解的很多东西，只会使用，也就是@XXX\n\n   那么，从今天开始，我希望你能够记住，对于注解而言，它一定有如下三个流程：\n\n   1. 定义注解\n   2. 使用注解\n   3. 读取并执行相应流程\n\n   下面我们就以@Repository这个注解来看看这三个流程，首先是定义注解，这个我们可以在IDEA中按住Ctrl点进去@Repository来看，是这样的：\n\n   ![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzQxODVlOTg2NGMxYzdmYzQxZmIxMTczZDY1MjZhOWRmLmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_4185e9864c1c7fc41fb1173d6526a9df.jpg)\n\n   这个就是@Repository注解的定义，接着我们看看@Repository的使用：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzQ4YTQ4YmY2YmNjOWY0NTgyMDYwMmIxNjcyNjllM2M5LmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_48a48bf6bcc9f45820602b167269e3c9.jpg)\n\n   然后就是对注解的读取了，怎么读取呢？很多人对这块是比较模糊的，这也是对注解理解最大的障碍所在。\n\n   我们一般就是使用注解，对于注解的定义和读取这块一般都是框架什么的给我们搞定了，我们不看源码一般不知道是怎么回事的，也就不清楚注解到底是怎么运行起来的，简单的理解就是注解需要靠反射去读取，然后做相应的处理。\n\n   但是我想你一定和我一样好奇，为啥加了个@Repository注解之后，这个UserBean就被装载进Sring容器中生成了一个bean呢？\n\n   还记得我在最开始就一直在说的吗？注解是需要有专门的程序取读取的，然后根绝读取到的注解获取的信息去执行相应的操作。\n\n   所以这里，在Spring源码中，一定有某个或者某些程序在做这个事情。\n\n   ## 注解的读取（注解如何起作用）\n\n   上面说了注解的定义何使用，在这里单独把注解的读取拿出来说下，因为这点事理解注解的重点，很多人觉得对注解不理解的一个原因就在于不清楚加了个注解之后到底干了啥？\n\n   也就是注解到底是如何起作用的？搞明白这个，将对你理解注解有极大的帮助。\n\n   ### 注解主要被反射读取\n\n   对于注解的读取，一般就是通过反射技术来实现，这里就有知识点了，对于反射而言，它只能读取内存中的字节码信息，然后还记得之前我们说的注解的作用域@Target吗？\n\n   它里面有几个主要的作用域，也就是这张图片，再来回顾下：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kX2FjYmZlY2EyNTBiNDc1ZjExZmMwMGE4ODIyZGQ2M2FiLmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_acbfeca250b475f11fc00a8822dd63ab.jpg)\n\n   对于RetentionPolicy.CLASS而言，这个就是指的字节码这一阶段，这个时候这个字节码文件是由Java源文件通过javac编译生成，这个时候class字节码文件其实还是在磁盘内，并没有进入内存中。\n\n   而反射只能取读取内存中的字节码信息，所以注解的保留策略也就是这个@Target只能是RUNTIME，也即运行的时候仍然可以读取。\n\n   ### 我的理解（精华）\n\n   很多人对注解不理解，或者觉得很模糊的一个原因就是你让我定义一个注解，我也能按照基本的注解语法去定义一个注解，你说怎么使用注解我也知道在类，方法等上面使用 @+注解名称的方式，但是也就到此为主了，更进一步的理解就有点模糊了，比如：\n\n   1. 为什么要这样用？\n   2. 原理是什么，怎么起作用的？\n\n   你想啊，我们就这样在类或者方法上面写了这么一个@+注解名称就行了？后续是怎么起作用的呢？这里你得首先清楚，注解有三大步骤：\n\n   1. 定义注解\n   2. 使用注解\n   3. 读取注解（这块是大部分人缺少的，也是大部分人对注解不理解的关键所在）\n\n   再理解下什么是注解，与注释一字之差，肯定有相似之处，两者都是提供额外信息的，好比备注，注释是给我们程序员看到，看到注释我们知道某个类是干啥的，有啥用，看到方法的注释，我们知道这个方法有什么作用需要什么参数以及参数的含义等等，那么注解嘞，注解其实是给程序看到，当程序读到注解，会从注解这里得到一些信息，知道该如何处理被该注解标记的类或方法等。\n\n   好好理解上面的，我们下面再以Spring的一个例子来加以说明。\n\n   对于Spring简单的大家都知道IOC吧，直白点就是不用你new对象，需要什么直接从Spring容器中获取，那么首先就需要把我们的bean注册到Spring容器中吧，这个一般有xml配置方式和注解方式，当然我们这里要说的是注解方式，也就是使用@+注解名称的形式，举个简单的例子，如下：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kX2Y3NTUxMDU5ZDA0MGM2NTI2YzEzNDY0YzE3NmYzYzY4LmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_f7551059d040c6526c13464c176f3c68.jpg)\n\n   这个注解熟悉吧，它就是可以把我们的Person类注册到Spring容器中去，当然，这里就是在对这个注解的使用，我们点进去看看这个注解是怎么定义的：\n\n   [![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5pdGh1YW5ncWluZy52aXAvd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvd3BfZWRpdG9yX21kXzU3Y2Q0MmZmYjZkZjJmMTQzYmIzZTgxMjBhZGRhYTJkLmpwZw?x-oss-process=image/format,png)](http://www.ithuangqing.vip/wp-content/uploads/2020/07/wp_editor_md_57cd42ffb6df2f143bb3e8120addaa2d.jpg)\n\n   这个定义我们应该已经熟悉了，对于@Component也是一个注解，它其实是最基础的把类注册到Spring容器中的注解，后来的像我们现在说的@Repositoy以及@Service和@Controller这些都是在@Component的基础上发而来。\n\n   这里就需要注意了，其实这几个注解不管是哪个，都要清楚明白的一点就是，要它们啥用，之所以需要这些注解，就是希望在哪个类上使用这些注解，就自动把这个类注册到Spring容器中，这个要比我们写xml配置简单的多，我们就在一个类上写个@Repositoy，它就被注册到Spring容器中了？\n\n   是不是很神奇，然后看下注解的定义，也很简单，没啥东西啊，怎么就自动注册到Spring容器中了呢？\n\n   还记得之前说的注解三大步骤嘛？首先你需要定义一个注解，然后就是使用注解，那么注解是怎么起作用的就需要有程序去读注解，这个注解就好比一个标志，一个标签一样，比如这里的@Repositoy，当一个类被这个注解标志，那么当特有的程序去读到这个注解的时候，这个程序就知道，哦，原来是要把这类注册到Spring容器中啊，那么程序怎么知道要把这个类注册到Spring容器中呢？这就是 @Repositoy 告诉它的。另外我们知道注解一般可以设置一个value属性值，可以通过反射技术拿到之类的，那么在具体的将这个类注册到Spring容器的过程中可能就会用到这个value属性值，比如设置成bean的名字。\n\n   我们一般使用了注解，在Spring配置文件中就需要配置注解的包扫描：\n\n   ```java\n   <context:component-scan base-package=\"com.ithuangqing.*\"/>\n   1\n   ```\n\n   这个其实就是在扫描，看看哪个类上使用到了@Repositoy这些注解，扫描到的就需要特殊处理将其注册到Spring容器。想一下，这里Spring其实就会对这个标签进行解析，核心代码：\n\n   ```java\n   registerBeanDefinitionParser(\"component-scan\", new ComponentScanBeanDefinitionParser());\n   1\n   ```\n\n   然后具体的处理流程就是在ComponentScanBeanDefinitionParser处理，代码如下：\n\n   ```java\n   @Override\n   \tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n   \t\tString basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);\n   \t\tbasePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);\n   \t\tString[] basePackages = StringUtils.tokenizeToStringArray(basePackage,\n   \t\t\t\tConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);\n   \n   \t\t// Actually scan for bean definitions and register them.\n   \t\tClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);    //得到扫描器\n   \t\tSet<BeanDefinitionHolder> beanDefinitions = scanner.doScan(basePackages);             //扫描文件，并转化为spring bean，并注册\n   \t\tregisterComponents(parserContext.getReaderContext(), beanDefinitions, element);       //注册其他相关组件\n   \n   \t\treturn null;\n   \t}\n   1234567891011121314\n   ```\n\n   上述代码的主要作用就是扫描base-package 下的文件，然后把它转换为Spring中的bean结构，接着将其注册到容器中……\n\n   怎么样，是不是越来越看不懂代码？很正常，这里只需要大家记住，注解是会被特有的程序去读取，然后去做相关的处理的，而这个处理逻辑，一般就比较复杂了，尤其框架中。\n\n   ### 获取注解的属性\n\n   上面讲解的关于注解是如何起作用的是很重要的，一定要理解，下面我们聊聊注解使用的最后一步：特有的程序去读取注解。\n\n   注解使用最终是需要依靠程序去读取注解，得到注解的一些信息，然后才判断接下来应该去做什么事情，那么接下来我们就要知道注解的属性值该如何获取。\n\n   其实注解的属性，用到的技术就是反射，反射是一个很重要的知识点，以后会单独写文通俗易懂的去聊一聊的。\n\n   接下来我们来看如何使用反射来获取注解的属性。，主要就是一下三个基本的方法：\n\n   ```java\n   /**是否存在对应 Annotation 对象*/\n   public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) \n   {\n       return GenericDeclaration.super.isAnnotationPresent(annotationClass);\n   }\n   \n   /**获取 Annotation 对象*/\n   public <A extends Annotation> A getAnnotation(Class<A> annotationClass) \n   {\n       return (A) annotationData().annotations.get(annotationClass);\n   }\n   \n   /**获取所有 Annotation 对象数组*/   \n   public Annotation[] getAnnotations() \n   {\n       return AnnotationParser.toArray(annotationData().annotations);\n   }\n   1234567891011121314151617\n   ```\n\n   然后接下来看一段简单的代码：演示利用注解获取注解属性\n\n   ```java\n   public class Test {\n       public static void main(String[] args) throws Exception {\n           Class<Test> testClass = Test.class;\n           Method toGetString = testClass.getMethod(\"toGetString\");\n           //获取注解对象\n           Main main = toGetString.getAnnotation(Main.class);\n           System.out.println(main.value());\n   \n       }\n   \n       @Main(\"这是自定义注解的value值\")\n       public static String toGetString() {\n           return \"\";\n       }\n   }\n   123456789101112131415\n   ```\n\n   其实很简单，记住以上三个获取注解的方法，关于反射我们后面会详细聊聊。\n\n   到现在基本知道了注解需要先定义出来，然后使用，那么怎么起作用，大概就是需要一个程序去专门利用反射技术去读取注解，得到注解里面的信息然后做相应的事情。\n\n   ## 总结\n\n   到这里，关于注解的讲解其实就差不多了，也许你看了也就忘了，也许你根本就没有看完，但是我希望记住一下内容：\n\n   1. 定义注解\n   2. 使用注解\n   3. 读取注解","tags":["注解"],"categories":["Java"]},{"title":"【HEXO】HEXO操作","url":"/2021/01/08/【HEXO】HEXO操作/","content":"\n### init\n\n```\n$ hexo init [folder]\n```\n\n新建一个网站。如果没有设置 `folder` ，Hexo 默认在目前的文件夹建立网站。\n\n### new\n\n```\n$ hexo new [layout] <title>\n```\n\n新建一篇文章。如果没有设置 `layout` 的话，默认使用 [_config.yml](https://hexo.io/zh-cn/docs/configuration) 中的 `default_layout` 参数代替。如果标题包含空格的话，请使用引号括起来。\n\n```\n$ hexo new \"post title with whitespace\"\n```\n\n| 参数              | 描述                                          |\n| :---------------- | :-------------------------------------------- |\n| `-p`, `--path`    | 自定义新文章的路径                            |\n| `-r`, `--replace` | 如果存在同名文章，将其替换                    |\n| `-s`, `--slug`    | 文章的 Slug，作为新文章的文件名和发布后的 URL |\n\n默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 `index.md` 文件。你可以使用 `--path` 参数来覆盖上述行为、自行决定文件的目录：\n\n```\nhexo new page --path about/me \"About me\"\n```\n\n以上命令会创建一个 `source/about/me.md` 文件，同时 Front Matter 中的 title 为 `\"About me\"`\n\n注意！title 是必须指定的！如果你这么做并不能达到你的目的：\n\n```\nhexo new page --path about/me\n```\n\n此时 Hexo 会创建 `source/_posts/about/me.md`，同时 `me.md` 的 Front Matter 中的 title 为 `\"page\"`。这是因为在上述命令中，hexo-cli 将 `page` 视为指定文章的标题、并采用默认的 `layout`。\n\n### generate\n\n```\n$ hexo generate\n```\n\n生成静态文件。\n\n| 选项                  | 描述                                                         |\n| :-------------------- | :----------------------------------------------------------- |\n| `-d`, `--deploy`      | 文件生成后立即部署网站                                       |\n| `-w`, `--watch`       | 监视文件变动                                                 |\n| `-b`, `--bail`        | 生成过程中如果发生任何未处理的异常则抛出异常                 |\n| `-f`, `--force`       | 强制重新生成文件 Hexo 引入了差分机制，如果 `public` 目录存在，那么 `hexo g` 只会重新生成改动的文件。 使用该参数的效果接近 `hexo clean && hexo generate` |\n| `-c`, `--concurrency` | 最大同时生成文件的数量，默认无限制                           |\n\n该命令可以简写为\n\n```\n$ hexo g\n```\n\n### publish\n\n```\n$ hexo publish [layout] <filename>\n```\n\n发表草稿。\n\n### server\n\n```\n$ hexo server\n```\n\n启动服务器。默认情况下，访问网址为： `http://localhost:4000/`。\n\n| 选项             | 描述                           |\n| :--------------- | :----------------------------- |\n| `-p`, `--port`   | 重设端口                       |\n| `-s`, `--static` | 只使用静态文件                 |\n| `-l`, `--log`    | 启动日记记录，使用覆盖记录格式 |\n\n### deploy\n\n```\n$ hexo deploy\n```\n\n部署网站。\n\n| 参数               | 描述                     |\n| :----------------- | :----------------------- |\n| `-g`, `--generate` | 部署之前预先生成静态文件 |\n\n该命令可以简写为：\n\n```\n$ hexo d\n```\n\n### render\n\n```\n$ hexo render <file1> [file2] ...\n```\n\n渲染文件。\n\n| 参数             | 描述         |\n| :--------------- | :----------- |\n| `-o`, `--output` | 设置输出路径 |\n\n### migrate\n\n```\n$ hexo migrate <type>\n```\n\n从其他博客系统 [迁移内容](https://hexo.io/zh-cn/docs/migration)。\n\n### clean\n\n```\n$ hexo clean\n```\n\n清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)。\n\n在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n\n### list\n\n```\n$ hexo list <type>\n```\n\n列出网站资料。\n\n### version\n\n```\n$ hexo version\n```\n\n显示 Hexo 版本。\n\n## 选项\n\n### 安全模式\n\n```\n$ hexo --safe\n```\n\n在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。\n\n### 调试模式\n\n```\n$ hexo --debug\n```\n\n在终端中显示调试信息并记录到 `debug.log`。当您碰到问题时，可以尝试用调试模式重新执行一次，并 [提交调试信息到 GitHub](https://github.com/hexojs/hexo/issues/new)。\n\n### 简洁模式\n\n```\n$ hexo --silent\n```\n\n隐藏终端信息。\n\n### 自定义配置文件的路径\n\n```\n# 使用 custom.yml 代替默认的 _config.yml\n$ hexo server --config custom.yml\n\n# 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高\n$ hexo generate --config custom.yml,custom2.json,custom3.yml\n```\n\n自定义配置文件的路径，指定这个参数后将不再使用默认的 `_config.yml`。\n你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：\n\n```\n# 使用 custom.yml 代替默认的 _config.yml\n$ hexo server --config custom.yml\n\n# 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json\n$ hexo generate --config custom.yml,custom2.json,custom3.yml\n```\n\n当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 `_multiconfig.yml`。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。\n\n### 显示草稿\n\n```\n$ hexo --draft\n```\n\n显示 `source/_drafts` 文件夹中的草稿文章。\n\n### 自定义 CWD\n\n```\n$ hexo --cwd /path/to/cwd\n```\n\n自定义当前工作目录（Current working directory）的路径。","tags":["hexo"],"categories":["hexo"]}]